import re
import os
from threading import Timer
from time import sleep

from evdev import InputDevice, categorize, ecodes

import firebase

# Initializing the output generated by the specific keys of the keyboard (non-SHIFT scancodes and SHIFT capscodes),
# represented by the scanner. Also some other stuff needs to be initialized.

scancodes = {
    0: None, 1: u'ESC', 2: u'&', 3: u'e', 4: u'"', 5: u'\'', 6: u'(', 7: u'6', 8: u'e', 9: u'!', 10: u'c', 11: u'a',
    12: u'-', 13: u'=', 14: u'BKSP',
    15: u'TAB', 16: u'a', 17: u'z', 18: u'e', 19: u'r', 20: u't', 21: u'y', 22: u'u', 23: u'i', 24: u'o', 25: u'p',
    26: u'[', 27: u']', 28: u'CRLF',
    29: u'LCTRL', 30: u'q', 31: u's', 32: u'd', 33: u'f', 34: u'g', 35: u'h', 36: u'j', 37: u'k', 38: u'l', 39: u'm',
    40: u'u', 41: u'`',
    42: u'LSHFT', 43: u'\\', 44: u'w', 45: u'x', 46: u'c', 47: u'v', 48: u'b', 49: u'n', 50: u',', 51: u';', 52: u':',
    53: u'=', 54: u'RSHFT', 56: u'LALT', 57: u' ', 100: u'RALT'
}

capscodes = {
    0: None, 1: u'ESC', 2: u'1', 3: u'2', 4: u'3', 5: u'4', 6: u'5', 7: u'6', 8: u'7', 9: u'8', 10: u'9', 11: u'0',
    12: u'_', 13: u'+', 14: u'BKSP',
    15: u'TAB', 16: u'A', 17: u'Z', 18: u'E', 19: u'R', 20: u'T', 21: u'Y', 22: u'U', 23: u'I', 24: u'O', 25: u'P',
    26: u'{', 27: u'}', 28: u'CRLF',
    29: u'LCTRL', 30: u'Q', 31: u'S', 32: u'D', 33: u'F', 34: u'G', 35: u'H', 36: u'J', 37: u'K', 38: u'L', 39: u'M',
    40: u'\'', 41: u'~',
    42: u'LSHFT', 43: u'|', 44: u'W', 45: u'X', 46: u'C', 47: u'V', 48: u'B', 49: u'N', 50: u'?', 51: u'.', 52: u'/',
    53: u'+', 54: u'RSHFT', 56: u'LALT', 57: u' ', 100: u'RALT'
}

# Some global variables need to be initialized on start

dir_path = os.path.dirname(os.path.realpath(__file__))
service_account_path = os.path.join(dir_path, "../ee5dashboard-firebase-adminsdk-v0ub6-acbcb82ad1.json")
config = {
    "apiKey": "",
    "authDomain": "",
    "databaseURL": "https://ee5dashboard.firebaseio.com/",
    "storageBucket": "",
    "serviceAccount": service_account_path
    }

# cred = credentials.Certificate("/home/pi/ee5_scratchpad/ee5dashboard-firebase-adminsdk-v0ub6-acbcb82ad1.json")
# firebase_admin.initialize_app(cred)

db = None

t = Timer(float('inf'), sleep(0))

serial = ''

dev = ''

old_scanned = ''
fn = ''
ln = ''
nr = 'r0482051'
uid = ''


def main():
    global db
    db = firebase.Firebase().db
    while (1):
        """ Method causing the program to run continously."""
        global old_scanned, t, serial, uid, dev

        # If the script doesn't know the serial of the pi yet, it should initialize this
        if serial == '':
            first_use()

        # If the uid is still unknown it is useless to continue
        if uid == '':
            if not uid_check():
                continue
            dev = InputDevice('/dev/input/event' + str(find_event()))

        dev.grab()
        try:

            data = read_out()

        except Exception as e:
            print "Scanner setup failed"
            print e.message
            return
        dev.ungrab()

        if data != old_scanned:  # If the same card is still on the sensor, no new db connection needs to be made
            if old_scanned != '':
                clear_db()
            old_scanned = data
            send_data(data)
        t.cancel()
        t = Timer(4, log_out)
        t.start()


def log_out():
    """ Method organizing the deletion of the last tagged user from the database. """
    global old_scanned
    clear_db()
    old_scanned = ''  # Last tagged user is deleted, control variable needs to be cleared aswelL
    t.cancel()


def read_out():
    """ Method reading the card that is scanned.
        :return The Name, Surname and ID of the cardholder in one string.:
    """
    global dev
    entry = ''
    caps = False
    for event in dev.read_loop():
        if event.type == ecodes.EV_KEY:
            data = categorize(event)  # Save the event temporarily to introspect it
            if data.scancode == 42:
                if data.keystate == 1:
                    caps = True
                if data.keystate == 0:
                    caps = False
            if data.keystate == 1:  # Down events only
                key_lookup = u'{}'.format(
                    capscodes.get(data.scancode) if caps else scancodes.get(data.scancode)) or u''
                if (data.scancode != 42) and (data.scancode != 28):
                    entry += key_lookup
                if data.scancode == 28:
                    return entry


def first_use():
    """
    When the script starts running, the serial code from the pi needs to be checked, and it needs to know is it's
    already linked to a UID (Hospital)
    :return: 
    """
    global serial
    serial = getserial()
    all_ids = db.child("IDMapping").get()
    if all_ids is not None:
        for ids in all_ids.each():
            if serial == ids.key():
                return
    db.child("IDMapping").child("" + serial).set({'UID': ""})
    with open("uid.txt", "w+") as f:
        f.write('1: ')

    return


def uid_check():
    global uid
    uids = db.child("IDMapping").child('' + serial).get()
    for puid in uids.each():
        uid = puid.val()
    if uid == '':
        return False
    return True


def getserial():
    """
    Method for getting your unique raspberry pi ID
    :return The serial code of your device: 
    """
    # Extract serial from cpuinfo file
    cpuserial = "0000000000000000"
    try:
        f = open('/proc/cpuinfo', 'r')
        for line in f:
            if line[0:6] == 'Serial':
                cpuserial = line[10:26]
        f.close()
    except:
        cpuserial = "ERROR000000000"

    return cpuserial


def find_event():
    """
    Method for recognizing the ID-scanner automatically.
    :return The event number:
    """
    found = -1
    index = 0
    with open('/proc/bus/input/devices') as k_file:
        for line in k_file:
            index += 1
            if "SpringCard RFIDScanner4KULeuven" in line:
                found = index + 3  # TODO code can improve to find line with event automatically
                break
    if found == -1:
        print "Can't find scanner. \nExiting program."
        quit(1)
    with open('/proc/bus/input/devices') as k_file:
        read = k_file.readlines()
        event_line = read[found]
        event_list = event_line.split()
        for word in event_list:
            if word.startswith("event"):
                return int(re.search(r'\d+', word).group())


def send_data(data):
    """
    Method sending the data to firebase and updating the global variables of firstname, lastname and id-number.
    :param data:
    """
    global db, fn, ln, nr

    firstname, data = split(data)
    lastname, data = split(data)
    number, data = split(data)
    fn = firstname
    ln = lastname
    nr = number
    if number == 'ERROR':
        return
    result = db.child('Tags').child('' + uid).update(
        {'LastTaggedFirstName': firstname, 'LastTaggedSecondName': lastname,
         'LastTaggedUser': number})
    print result


def split(line):
    """
    Method splitting the string into parts.
    :param line: 
    :return Part of the input string ending in a ':' or space as word and the rest as line: 
    """
    if line == '':
        return 'ERROR', ''
    word = ''
    while line[0] != ';':
        word = '%s%s' % (word, line[0])
        line = line[1:]

        if line == '' or line == ';':
            break
    line = line[1:]
    return word, line


def clear_db():
    """ Clears the database input of the last tagged user. """
    global db, fn, ln, nr
    fn = ''
    ln = ''
    nr = ''
    db.child("Tags").child('' + uid).update(
        {'LastTaggedFirstName': '', 'LastTaggedSecondName': '', 'LastTaggedUser': ''})


def get_firstname():
    global fn
    return fn


def get_lastname():
    global ln
    return ln


def get_number():
    global nr
    return nr


if __name__ == "__main__":
    main()
